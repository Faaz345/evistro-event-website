-- Supabase Database Setup Script (Fixed)
-- Execute this script in the Supabase SQL Editor to recreate your database

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS http WITH SCHEMA extensions;

-- Create tables
-- Events table
CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  date DATE NOT NULL,
  location TEXT NOT NULL,
  image_url TEXT,
  category TEXT NOT NULL,
  featured BOOLEAN DEFAULT false
);

-- Event Registrations table
CREATE TABLE IF NOT EXISTS public.event_registrations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL,
  event_date DATE NOT NULL,
  guest_count INTEGER NOT NULL,
  location TEXT NOT NULL,
  budget NUMERIC NOT NULL,
  special_requests TEXT,
  contact_phone TEXT NOT NULL,
  contact_email TEXT NOT NULL,
  payment_status TEXT NOT NULL CHECK (payment_status IN ('pending', 'partial', 'complete')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('submitted', 'confirmed', 'in-progress', 'completed', 'cancelled')),
  start_time TIME,
  end_time TIME
);

-- Event Tracking table
CREATE TABLE IF NOT EXISTS public.event_tracking (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  event_type TEXT NOT NULL,
  event_date DATE NOT NULL,
  location TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('upcoming', 'cancelled', 'completed')),
  booking_id UUID NOT NULL REFERENCES public.event_registrations(id) ON DELETE CASCADE,
  start_time TIME,
  end_time TIME
);

-- Contacts table for contact form submissions
CREATE TABLE IF NOT EXISTS public.contacts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  message TEXT NOT NULL,
  responded BOOLEAN DEFAULT false
);

-- Bookings table (for admin management)
CREATE TABLE IF NOT EXISTS public.bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  phone TEXT,
  guests INTEGER NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('pending', 'confirmed', 'cancelled'))
);

-- Admin users table (instead of modifying auth.users directly)
CREATE TABLE IF NOT EXISTS public.admin_users (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL
);

-- Create a function to check if a user is an admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    SELECT EXISTS (
      SELECT 1 FROM public.admin_users
      WHERE user_id = auth.uid()
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a secure function to delete users
CREATE OR REPLACE FUNCTION delete_user()
RETURNS json AS $$
DECLARE
  current_user_id UUID;
BEGIN
  -- Get the current user's ID
  current_user_id := auth.uid();
  
  -- Check if the user is authenticated
  IF current_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Delete user data from tables
  DELETE FROM public.event_registrations WHERE user_id = current_user_id;
  DELETE FROM public.bookings WHERE user_id = current_user_id;
  DELETE FROM public.contacts 
  WHERE email = (SELECT email FROM auth.users WHERE id = current_user_id);
  
  -- Mark the user as deleted in their metadata (using RPC function instead of direct update)
  PERFORM supabase_functions.http(
    'POST',
    CONCAT(current_setting('app.settings.supabase_url', true), '/auth/v1/admin/users/', current_user_id),
    ARRAY[
      ARRAY['Authorization', CONCAT('Bearer ', current_setting('app.settings.service_role_key', true))],
      ARRAY['Content-Type', 'application/json']
    ],
    'application/json',
    '{"user_metadata": {"deleted": true}}'
  );
    
  -- Return success
  RETURN json_build_object('success', true);
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create the webhook function that will be called via Edge Functions
CREATE OR REPLACE FUNCTION delete_user_by_id(id UUID)
RETURNS json AS $$
DECLARE
  url text;
  auth text;
  result json;
BEGIN
  -- Set the URL and authorization (these will be set by Edge Function)
  url := CONCAT(current_setting('app.settings.supabase_url', true), '/auth/v1/admin/users/', id);
  auth := CONCAT('Bearer ', current_setting('app.settings.service_role_key', true));
  
  -- Delete user data first
  DELETE FROM public.event_registrations WHERE user_id = id;
  DELETE FROM public.bookings WHERE user_id = id;
  
  -- Make the HTTP request to delete the user from Auth
  SELECT content INTO result FROM 
  http((
    'DELETE',
    url,
    ARRAY[http_header('Authorization', auth), http_header('Content-Type', 'application/json')],
    'application/json',
    '{}'
  )::http_request);
  
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Set up Row Level Security policies
-- Events table policies
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public read access for events"
ON public.events FOR SELECT
USING (true);

CREATE POLICY "Admin full access for events"
ON public.events FOR ALL
USING (is_admin());

-- Event registrations policies
ALTER TABLE public.event_registrations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read their own registrations"
ON public.event_registrations FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own registrations"
ON public.event_registrations FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own registrations"
ON public.event_registrations FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Admin full access for event_registrations"
ON public.event_registrations FOR ALL
USING (is_admin());

-- Contacts table policies
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public insert access for contacts"
ON public.contacts FOR INSERT
WITH CHECK (true);

CREATE POLICY "Admin full access for contacts"
ON public.contacts FOR ALL
USING (is_admin());

-- Bookings policies
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read their own bookings"
ON public.bookings FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Admin full access for bookings"
ON public.bookings FOR ALL
USING (is_admin());

-- Admin users policies
ALTER TABLE public.admin_users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admin users can be read by anyone"
ON public.admin_users FOR SELECT
USING (true);

CREATE POLICY "Only super admins can modify admin users" 
ON public.admin_users FOR ALL
USING (is_admin());

-- Store the necessary settings (replace with actual values)
-- DO $$
-- BEGIN
--   PERFORM set_config('app.settings.supabase_url', 'YOUR_SUPABASE_URL', FALSE);
--   PERFORM set_config('app.settings.service_role_key', 'YOUR_SERVICE_ROLE_KEY', FALSE);
-- END $$;

-- Grant permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon, authenticated, service_role;

-- Remember to replace placeholders with your actual values:
-- 1. YOUR_SUPABASE_URL - Your new Supabase project URL
-- 2. YOUR_SERVICE_ROLE_KEY - Your new Supabase service role key

-- To make a user an admin, run:
-- INSERT INTO public.admin_users (user_id) VALUES ('your-user-id-here'); 