-- Supabase Database Setup Script
-- Execute this script in the Supabase SQL Editor to recreate your database

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS http WITH SCHEMA extensions;

-- Create tables
-- Events table
CREATE TABLE IF NOT EXISTS public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  date DATE NOT NULL,
  location TEXT NOT NULL,
  image_url TEXT,
  category TEXT NOT NULL,
  featured BOOLEAN DEFAULT false
);

-- Event Registrations table
CREATE TABLE IF NOT EXISTS public.event_registrations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL,
  event_date DATE NOT NULL,
  guest_count INTEGER NOT NULL,
  location TEXT NOT NULL,
  budget NUMERIC NOT NULL,
  special_requests TEXT,
  contact_phone TEXT NOT NULL,
  contact_email TEXT NOT NULL,
  payment_status TEXT NOT NULL CHECK (payment_status IN ('pending', 'partial', 'complete')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('submitted', 'confirmed', 'in-progress', 'completed', 'cancelled')),
  start_time TIME,
  end_time TIME
);

-- Event Tracking table
CREATE TABLE IF NOT EXISTS public.event_tracking (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  event_type TEXT NOT NULL,
  event_date DATE NOT NULL,
  location TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('upcoming', 'cancelled', 'completed')),
  booking_id UUID NOT NULL REFERENCES public.event_registrations(id) ON DELETE CASCADE,
  start_time TIME,
  end_time TIME
);

-- Contacts table for contact form submissions
CREATE TABLE IF NOT EXISTS public.contacts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  message TEXT NOT NULL,
  responded BOOLEAN DEFAULT false
);

-- Bookings table (for admin management)
CREATE TABLE IF NOT EXISTS public.bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL,
  event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  phone TEXT,
  guests INTEGER NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('pending', 'confirmed', 'cancelled'))
);

-- Add admin role column to auth.users via custom metadata
-- This will store admin status in user_metadata
ALTER TABLE auth.users ADD COLUMN IF NOT EXISTS is_admin BOOLEAN DEFAULT false;

-- Create a function to check if a user is an admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    SELECT EXISTS (
      SELECT 1 FROM auth.users
      WHERE id = auth.uid() AND is_admin = true
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a secure function to delete users
CREATE OR REPLACE FUNCTION delete_user()
RETURNS json AS $$
DECLARE
  current_user_id UUID;
BEGIN
  -- Get the current user's ID
  current_user_id := auth.uid();
  
  -- Check if the user is authenticated
  IF current_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Delete user data from tables
  DELETE FROM public.event_registrations WHERE user_id = current_user_id;
  DELETE FROM public.bookings WHERE user_id = current_user_id;
  DELETE FROM public.contacts 
  WHERE email = (SELECT email FROM auth.users WHERE id = current_user_id);
  
  -- Mark the user as deleted in their metadata
  UPDATE auth.users
  SET raw_user_meta_data = 
    COALESCE(raw_user_meta_data, '{}'::jsonb) || '{"deleted": true}'::jsonb
  WHERE id = current_user_id;
    
  -- Return success
  RETURN json_build_object('success', true);
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create the webhook function that will be called via Edge Functions
CREATE OR REPLACE FUNCTION delete_user_by_id(id UUID)
RETURNS json AS $$
DECLARE
  url text;
  auth text;
  result json;
BEGIN
  -- Set the URL and authorization (these will be set by Edge Function)
  url := CONCAT(current_setting('app.settings.supabase_url', true), '/auth/v1/admin/users/', id);
  auth := CONCAT('Bearer ', current_setting('app.settings.service_role_key', true));
  
  -- Delete user data first
  DELETE FROM public.event_registrations WHERE user_id = id;
  DELETE FROM public.bookings WHERE user_id = id;
  
  -- Make the HTTP request to delete the user from Auth
  SELECT content INTO result FROM 
  http((
    'DELETE',
    url,
    ARRAY[http_header('Authorization', auth), http_header('Content-Type', 'application/json')],
    'application/json',
    '{}'
  )::http_request);
  
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Set up Row Level Security policies
-- Events table policies
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public read access for events"
ON public.events FOR SELECT
USING (true);

CREATE POLICY "Admin full access for events"
ON public.events FOR ALL
USING (is_admin());

-- Event registrations policies
ALTER TABLE public.event_registrations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read their own registrations"
ON public.event_registrations FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own registrations"
ON public.event_registrations FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own registrations"
ON public.event_registrations FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Admin full access for event_registrations"
ON public.event_registrations FOR ALL
USING (is_admin());

-- Contacts table policies
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public insert access for contacts"
ON public.contacts FOR INSERT
WITH CHECK (true);

CREATE POLICY "Admin full access for contacts"
ON public.contacts FOR ALL
USING (is_admin());

-- Bookings policies
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read their own bookings"
ON public.bookings FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Admin full access for bookings"
ON public.bookings FOR ALL
USING (is_admin());

-- Set up initial data (optional)
-- Insert sample event types if needed
-- INSERT INTO public.event_types (name, description)
-- VALUES 
--   ('Wedding', 'Wedding and reception events'),
--   ('Birthday', 'Birthday celebrations'),
--   ('Corporate', 'Business meetings and corporate events')
-- ON CONFLICT DO NOTHING;

-- Store the necessary settings (replace with actual values)
-- DO $$
-- BEGIN
--   PERFORM set_config('app.settings.supabase_url', 'YOUR_SUPABASE_URL', FALSE);
--   PERFORM set_config('app.settings.service_role_key', 'YOUR_SERVICE_ROLE_KEY', FALSE);
-- END $$;

-- Grant permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon, authenticated, service_role;

-- Remember to replace placeholders with your actual values:
-- 1. YOUR_SUPABASE_URL - Your new Supabase project URL
-- 2. YOUR_SERVICE_ROLE_KEY - Your new Supabase service role key 